# 题目 #

根据这道题的条件特点：
如果两间相邻的房屋在同一晚上被小偷闯入，系统会自动报警（即相邻的数字不能同时作为最终求和的有效数字）。

## 分析 ##

这个条件如果精简掉其他内容，很容易让人联想到奇偶数。这个解法就是从这点出发。

1. 设置两个变量，sumOdd 和 sumEven 分别对数组的奇数和偶数元素求和。  
1. 最后比较这两个和谁更大，谁就是最优解。

至少在下面这个例子里，这么做是成功的了。

 | Index | [0] |[1] |	[2] |	[3] |
|----|----|----|----|----|
|nums |	1| 	2| 	3 |	4|
|sumEven |	1| 	1| 	4| 	4|
|sumOdd |	0 |	2| 	2| 	6|

接下来要解决的就是最优解不是纯奇数和或者偶数和的情况。
这种情况下，最优解可能前半段出现在这边，后半段出现在另一边。
那么只要找到一个时机，当这一段的最优解没有另一边好时，就复制对面的最优解过来。

举个例子：

 | Index | [0] |[1] |	[2] |	[3] | [4] |
|----|----|----|----|----|----|
|nums |	1| 	3| 	1| 	3| 	100|
|sumEven |	1 |	1 |	2| 	2 => 3 |	
|sumOdd |	0| 	3| 	3| 		

当偶数和（奇偶指的数组下标）加到第二个 1 之后，发现还不如奇数和一个 3 大，就应该将对面的3复制过来替换掉自己的 2。

| Index | [0] |[1] |	[2] |	[3] | [4] |
|----|----|----|----|----|----|
|nums |	1 |	3 |	1 |	3 |	100 |
|sumEven | 	1 |	1 |	2 |	3 |	103 |
|sumOdd |	0 |	3 |	3 |	6 |	6 |

继续计算后得到最优解。

## 思路 ##

1. 设置两个变量，sumOdd 和 sumEven 分别对数组的奇数和偶数元素求和。
1. 遍历数组，索引为奇数时，将元素加到奇数和，并与偶数和比较更新成max。
1. 偶数和同理。
1. 返回时进行最后一次更新max。

## 答题 ##
```asm
int rob(vector<int>& nums) 
{
	int sumOdd = 0;
	int sumEven = 0;

	for (int i = 0; i < nums.size(); i++)
	{
		if (i % 2 == 0)
		{
			sumEven += nums[i];
			sumEven = max(sumOdd, sumEven);
		}
		else
		{
			sumOdd += nums[i];
			sumOdd = max(sumOdd, sumEven);
		}
	}
	return max(sumOdd, sumEven);
}
```


完成。

作者：ikaruga
链接：https://leetcode-cn.com/problems/house-robber/solution/da-jia-jie-she-by-ikaruga/
来源：力扣（LeetCode）
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。